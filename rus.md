# Создание непрямоугольных макетов при помощи CSS-форм

Сегодня вы можете создавать любые [виды форм][1] при помощи css-трансформаций, но эти формы не могут влиять на поведение содержимого внутри них или вокруг них. Например, если вы создаете треугольник или трапецию посредством CSS, то созданная форма не определяет и не влияет на то как будет вести себя текст внутри фигуры или вне ее. 

С появлением CSS-форм в вебе стало проще обернуть контент в пользовательскую непрямоугольную форму или же воссоздать типографические (печатные) проекты и макеты.

В этой статье я собираюсь перейти к описанию базовых форм и созданию простых макетов с использованием новых CSS-технологий. Когда большинство CSS-форм будет внедрено, тогда все больше сложных и *разнообразных* макетов будет доступно, но даже с тем что мы сейчас имеем можно создать несколько [интересных макетов][2], нужно всего лишь поэксперементировать.

**CSS-технологии о которых я буду рассказывать в этой статье являются передовыми и не все браузеры их поддерживают. Если вы хотите увидеть работающие живые демонстрации кода, тогда вы должны убедиться, что смотрите в браузерах, которые поддерживают эти технологии.
Хотя вам совсем и не обязательно нужны эти браузеры, чтобы понять идею или код. Я вставила скриншоты демо-версий так что вы сможете увидеть как выглядит финальный результат.**

На тот момент, когда я писала статью, только Chrome Canary [поддерживал версию css форм без префиксов][3], но для этого его надо запускать со специальным флагом. Убедитесь, что вам [доступны возможности css форм][4], чтобы смотреть на работающие демонстрации.

Пожалуйста учтите, что часть информации упоминаемая в этой статье может быть изменена, когда поддержка CSS форм будет увеличена(расширена) и многие возможности этой спецификации будут реализованы. 


## Объявление формы

Все HTML-элементы имеют прямоугольную блочную модель, которая регулирует поток внутри и снаружи нее. Для того, чтобы придать элементу пользовательскую непрямоугольную форму мы используем свойства: `shape-inside` и `shape-outside`. Во время того как я писала эту статью свойство `shape-outside` применялось только для плавающих элементов, а свойство `shape-inside` не было полностью внедрено, поэтому при использовании этих свойств у вас могут возникать ошибки.
Shape-свойства могут применяться только к блочным элементам. Неблочные элементы должны приводиться стилями к блочным и только тогда можно использовать shape-свойства.

Shape-* свойства берут одно из трех значений: auto, базовая фигура или image URI.
Если свойство установлено в auto, то плавающие элементы используют margin box в обычном режиме. Если вы не знакомы с [CSS box-model][5], то рекомендую ознакомиться, потому что вы должны знать, как это работает.

Если свойство установлено в «shape function», то форма вычисляется на основе выбора одного из значений функций - `rectangle`, `inset-rectangle`, `circle`, `ellipse`, `polygon`. Вы можете узнать намного больше об этих функциях в [статье][6] от команды Adobe Platform.

И наконец, если свойство установлено в image URI — браузер будет использовать изображение для извлечения и вычисления формы, основанной на альфа-канале изображения. Форма вычисляет путь, который охватывает область, где непрозрачность указаного изображения больше чем `shape-image-threshold` значение. Если `shape-image-threshold` не указано, то начальное значение будет установлено `0.5`. Изображение должно быть CORS-same-origin, в противном случае оно не будет работать и значение автоматически установится в `auto`.(!!!узнать про вычисленную форму)

Формы, определенные при помощи `shape-outside` свойства определяют *область исключения* на элементе, а те, которые определены с помощь свойства `shape-inside`, определяют *плавающую область* на элементе. На примерах приведенных ниже мы узнаем, что это означает.

Формы определеные при помощи shape-* свойств могут быть изменены при помощи `shape-margin` and `shape-padding`. Эти свойства говорят сами за себя.


## Создание системы координат на элементе.

Чтобы использовать CSS-формы на элементах, вы сначала должны установить систему координат, которая будет использоваться для рисования форм/фигур.

Система координат обязательна, так как формы, которые вы задаете будут определены через набор точек(и радиусов, если рисовать круги или элипсы) и эти точки имеют кооридинаты x and y на координатной оси.

The shape-* свойста используют контейнер содержимого элемента и применяют к нему систему координат, поэтому вам нужно указать фиксированную ширину и высоту для элемента, которые определяют границы, которые в свою очередь будут использоваться для установления системы координат для отрисовки фигур. **Если явно ширина и высота не указаны свойства фигур работать не будут.**

Центр системы координат установливается в верхний левый угол.

Итак, для задания формы на элементе вы должны сначала: 
1. Задать конкретные значения элементу (помните, что он должен быть плавающим, если используете `shape-outside` )
2. Использовать shape-* свойства.


### Применение фона к настраиваемым элементам

>В то время как мы можем ограничивать строчный контент с помощью shapes (форм) реальный его контейнер не изменится. Если элемент имеет конкретные внешние и внутрение отступы, границы, то они будут расчитаны в соотвествии с [CSS3BOX][7]. — [W3C CSS Shapes Module Level 1][8] 



Другими словами, форма определеная на элементе используя shape-* свойства влияет *только* на плавающую площадь элемента, то есть на поток внутри/снаружи элемента, но остальные свойства не изменяются.

Например, предположим что вы хотите нарисовать круглую форму и имеете отбтекающий контент в виде фигуры, что на рисунке ниже, сначала вы объявили круглую форму на элементе(напоминаю, что плавающему элементу нужно задать высоту и ширину). Затем вы захотите применить цветной фон, чтобы она выглядела как на картинке.. 

![Фон применен к заданой пользователем форме][9]


Вам хочется просто указать фон содержащему элементу, чтобы результат бы таким как на картинке выше, но это так не работает. Дело в том, что все свойства элемента, кроме потока за его пределами, не зависят от формы заданой внутри него и они будут отрисовываться в обычном режиме согласно блочной модели элементов(прямоугольной формы), как мы читали в спефикации выше. Так что, если вы примените цвет фона к элементу, то ...

![Фон применется к форме прямоугольной коробки элемента][10]

*Как же применить цвет только к форме, а не ко всему элементу сразу?* Вот где свойство `clip-path` из [CSS-спецификации][11] может помочь.

Свойство `clip-path` используется для *отсечения* частей элемента, которые нам не понадобятся. Очевидно, что это означает, что мы не применили цвет к форме, а только *обрезали* элемент и оставили нетронутой форму. При этом текст будет обтекать круг.

*Каким образом? Какое значение свойства clip-path заставляет так работать?*

Пользовательская система координат для форм определеных при помощи свойства `clip-path` устанавливается используя границы элемента для которых `clip-path` был применен, поэтому система координат аналогична для shape-* свойств.

Благодаря этому мы можем использовать ту же фигуру определенную в shape-* свойстве для обрезающего пути, которая будет обрезана или вырезать все внутри содержащего элемента что снаружи границ фигуры(!!!) в результате мы получим настраиваемую фигуру с фоном. 

Вы можете протестировать эту идею [в живую][12], только убедитесь что вы тестируете в поддерживающем браузере.


## Краткое (быстрое) напоминание.

На момент редактирования статьи свойство `shape-outside` работало только на плавающих элементах и оба свойства `shape-outside` и `shape-inside` применялись только к блочным элементам или же к инлайновым элементам *приведенным к блочным*.
Фигура определенная, как плавающая будет использовать инлайновый контент для обертки вокруг заданой формы. Будущие уровни CSS-форм позволят использовать фигуры не только на плавающих элементах и когда это случится мы сможем оборачивать контент с двух сторон формы (как на картинке ниже). 

![Расположение контента с двух сторон от CSS-формы][13]

Вы можете поддельно упаковать контент с двух сторон используя 
[плагин Исключающего удара(Exclusion Punch plugin)][14] от [Биара Трэвиса][15] (Bear Travis).

А теперь давайте нарисем пару форм и создадим несколько интересных макетов!

Каждый из следующих примеров представляет собой новую подсказку, идею или технику, которая используется для определения и использования CSS-форм и исключений. 

**Вы можете посмотреть живое демо для каждого примера просто кликнув на скриншот**

### Пример 1: Плавающий текст вокруг пользовательской формы с `shape-outside` 
Мы начнем с простого примера. В этом примере мы собираемся определить пользовательскую форму и обтекающий контент. Результат будет выглядеть как на картинке ниже:

[![Скриншот демо #1. Нажмите на скриншот чтобы увидеть работающее демо][16]][17]

В демо примере мы имеем два элемента: `.content` — контейнер с текстом слева и другой элемент `.shaped` зафлоаченый вправо, который получит собственную форму и будет иметь обтекающий слева текст. Заголовок в блоке `.content` получит такое же поведение, которое мы дадим диву зафлоченому направо. Я пропущу объяснения и буду рассказывать только про что мы делаем с блоком `.shaped`.

    <div class="container">
      <div class="shaped"></div>
      <div class="content">
        <h1><span>La</span> Tour <br/>Eiffel</h1>
        <p>Lorem Ipsum…</p>
      </div>
    </div>        

Сперва мы зададим плавающему элементу `div` конкретную высоту и ширину для установки системы координат. Мы установим высоту равную высоту контейнера, которому для этого примера я установила высоту вьюпорта используя css `vh` еденицу. 

    .container{
      overflow:hidden;
      height: 100vh;
      width: 100vw;
    }
    .shaped{
      float:left;
      height:100vh;
      width:40vw;
      float:right;
      background: black url(../images/eiffel.jpg) center top no-repeat;
      background-size:cover;
    }             

Сейчас, когда система координат готова, мы можем определить плавающие участки и исключения элемента. Тут два пути объявления формы для этого примера:


## Использование polygon()

В первом способе мы будем использовать функцию polygon(). Данная функция принимает набор точек, которые образуют прямоугольник, каждая точка задается через координаты `x` и `y`. Мы собираемся определить очень простую прямоугольную фигуру с 4 вершинами, как показано на рисунке ниже (оранжевые и голубые точки):

![][18]

Координаты точек могут иметь либо конкретные значения (`px` или `em`) или процентные значения. В этом примере мы устанавливаем процентные значения для вершин. 
Сейчас всё, что мы должны сделать это объявить форму на плавающем элементе так чтобы текст обтекал его.

    .shaped{
      /*…*/
      shape-outside: polygon(0 0, 100% 0, 100% 100%, 30% 100%);
      shape-margin: 20px;
    }         

И это все! Теперь текст обтекает плавающий элемент, по специальной форме, которую мы определили.

Также вы можете видеть, что я добавила внешний отступ, чем отдалила содержимое от формы и создала промежуток между ними.

Но нужно добавить кое-что еще. Как я упоминала в предыдущей часте фон плавающего элемента применяется к оригинальной прямоугольной форме, не к форме определенной на нем, потому что свойство фона не распосраняется на форму определенную на элементе. В демке это вы глядит так:

![][19]

Поэтому мы вырезаем лишнюю часть используя свойство `clip-path` и дадим тоже значение/форму что мы дали свойству `shape-outside` выше. Мы добавим это правило в набор правил: 

    .shaped{
      /*...*/
      clip-path: polygon(0 0, 100% 0, 100% 100%, 30% 100%);
    }
                  

Вот мы и закончили! Легко, не правда ли?

Заголовок страницы слева имеет такое же поведение как и `.floated` `div` обтекающий справа. Заголовок плавает внутри контейнера `.content`, ему дана конкретная высота и ширина для установки системы координат, форма уставливается на нем при помощи свойства `shape-outside` также как мы это делали для элемента `.floated`.


## Использование image URI

Второй способ с помощью которого мы можем определять формы на элементах это использовать изображения с альфа-каналом, то есть любые изображения с прозрачностью.
 

Для примера, вместо использования функции `polygon()` для определения формы, мы укажем в свойстве `shape-outside` image URI, в результате чего браузер достанет форму из изображения и использует ее.

На примере ниже видно изображение, которое иллюстрирует исключающую область. Можно заметить, что это изображение повторяет фигуру созданную с помощью функции `polygon()` из точек предыдущего метода. 

![][20]

Когда мы используем изображения с альфа каналом для определения формы через свойство shape-outside, прозрачная область изображения будет обозначать область, где текст будет обрамлять заданую форму, это область будет называться *плавающей областью* элемента. Черная часть определяет область исключения элемента. 

Для использования изображения мы напишем следующее: 

    .shaped{
      /*…*/
      shape-outside: url(../images/mm.png);
      shape-image-threshold: 0.5; /* this property is used to set the threshold used
                                    for extracting a shape from an image.
                                    0.0 = fully transparent and 1.0 = fully opaque
                                  */
    }


Каждый из указанных двух методов имеет свои преимущества. Следует использовать изображения с альфа каналом для сложных фигур где могло бы быть затруднительно (громоздко) создавать точки вручную, в этом случае создание изображения в Фотошопе будет намного проще и быстрее чем добавление точек руками.

Другая ситуация когда вы можете захотеть использовать image URI вместо функции формы - это когда у вас много плавающих или исключающих областей в элементе, в этом случае использование этого метода обязательно потому что вы не можете, пока что, объявлять несколько форм на одном элементе, но если изображение имеет много областей браузер извлечет эти области из изображения и будет использовать их. 
Неплохо, правда? Пример такого случая в последнем демо. 


### Пример 2: обворачивание/обтекание текста внутри пользовательской формы при помощи shape-inside

Для второго примера мы создадим простую демонстрацию где окончательный результат будет выглядеть вот так:

[![][21]][22]

Цель этого примера показать использование свойства `shape-inside` для плавающего текста в непрямоугольной форме. У нас есть контейнер с несколькими заглушками текста внутри него и фоновая фотография у контейнера.

    <div class="container">            
      <div class="content">
          <p>…</p>
      </div>
      <h2>Corn Bread</h2>
    </div>    

На этом скриншоте мы видим, что текст находится внутри округлой формы вверху. А это означает, что мы будем объявлять круг на нашем контейнере. Сейчас как и в предыдущем примере у нас есть два способа как это можно сделать.

### Использование `circle()` 

Функция `circle()` имеет три аргумента: `cx`, `cy` и `r` (радиус), где `cx` и `cy` координаты центра окружности и `r` — это радиус окружности. 

На рисунке ниже видно, что система координат установлена на элементе и окружность находится внутри элемента. Мы можем убедиться, что окружность установлена над изображением сковороды, что на фото, которое мы используем как фоновое изображение, так что кажется что текст содержится внутри сковородки. 
На картинке так же видно, что центр окружности установлен по отношению к системы координат на элементе. 

![][23]

Так как мы хотим обвернуть текст *внутри* пользовательской формы и не обеткать его(!!!!) вокруг мы собираемся использовать свойство `shape-inside` к элементу который содержит этот текст. Когда мы применяем свойство `shape-inside` к элементу мы должны помнить что этот элемент должен иметь текст внутри себя, что не похоже на  предыдущий пример, где контент был снаружи. 

Мы укажем координаты центра окружности в абсолютных величинах в этот раз, не в процентах, и установим значение радиуса и применим это все к контейнеру: 

    .container{
      float:left;
      width:600px;
      height:900px;
      overflow:hidden;
      margin:0 50px;
      color:white;
      font-size:13px;
      padding:10px;
      background: url(../images/pan.jpg) top left no-repeat;
      background-size:100% 100%;
      /* declare shape using the shape function circle() */
      shape-inside: circle(400px, 60px, 160px);
    }

Конечно, если вы не пытаетесь создать окружность идеальной формы вы так же можете определить форму при помощи функиции `polygon()`.


### Использование image URI

Мы так же можем использовать URI изображения с альфа-каналом чтобы достать форму окружности из нее. Картинка будет выглядеть следующим образом:

![][24]

Очень важно отметить здесь что когда мы используем изображения с альфа-каналом для определения формы **со свойством `shape-inside`** *черная (или непрозрачная) область* изображения будет определять область где будет находится текст. В прошлом примере непрозрачная область определяла *область исключения* элемента на котором мы применили форму, т.е. область где нет текста. 

Объявляя форму используя image URI вместо функции `circle()` вы должны будете указать в значение свойства `shape-inside` ссылку на image URI.   

    .container{
      /*...*/
      shape-inside: url(mask.png) top left;
    }             


### Пример 3: обворачивание/обтекание текста внутри пользовательской формы при помощи shape-inside

В этом примере мы также объявим многоугольную форму на контейнере и зададим контент внутри этой формы. Конечный результат будет выглядеть вот так:

![][25]

В данном случае мы так же можем использовать функцию для описания формы или изображения с альфа-каналом.

Форма, объявленая для этого контейнера, — это явно «случайная» многоугольная форма, а не геометрическая форма, которую можно было объявить, используя функции форм вроде `circle()`, `ellipse()` или `rectangle()`, поэтому для ее объявления мы будем использовать функцию `polygon()`. 

На рисунке снизу показана форма, задаваемая набором точек.

![][26]

Так как эта форма задается довольно большим количество точек вычислять их координаты было бы утомительно, поэтому было бы намного проще, если бы существовал *визуальный* инструмент, который помог бы расставить точки на изображении, правда ведь? И такой инструмент существует и создан [Bear Travis][27] из Adobe, на самом деле это набор инструментов который поможет вам при работе с CSS-формами. Обязательно посмотрите на [Shape Tools][28] потому что они очень полезны.

Один из инструментов Shape tools называется [Poly Draw][29] и он позволяет вам вручную рисовать форму, многоугольник в частности и затем он генирирует координаты формы, которые вы можете скопировать и вставить в свой CSS чтобы задать форму на элементе.  

Я использовала инструмент Poly Draw для того что нарисовать форму изображеную на рисунке сверху. В данный момент вы не можете указать инструменту изображение, которое бы оно установило бы как фоновое на котором вы бы нарисовали свою форму, поэтому я склонировала репозиторий, немного изменила код, применила свое изображение и расставила точки. 

[Рэзвэн Кэлимэн][30] (Razvan Caliman) предложил мне эту идею, когда я спросила его о доступности инструмента, который позволял бы определять формы на картинке прямо в браузере, такого же как и тот что он показывал во время [своего выступления на CSS-конференции Conf EU][31]. Если вы еще не видели, то обязательно посмотрите. Исходиники этого инструмента когда-нибудь, очень надеюсь, что скоро, будут открыты компанией Adobe и тогда этот инструмент станет незаменимым при работе с CSS-формами. Ну, а пока можно обходиться инструментом Poly Draw.

После того как нарисовали форму при помощи Poly Draw все что нужно это объявить результрующую форму элемента и это все. 

    .container{
      width:445px;
      height:670px;
      overflow:hidden;
      margin:30px auto;
      /*shape generated by the Poly Draw tool*/
      shape-outside: polygon(170.67px 291.00px,126.23px 347.56px,139.79px 417.11px,208.92px 466.22px,302.50px 482.97px,343.67px 474.47px,446.33px 452.00px,443.63px 246.82px,389.92px 245.63px,336.50px 235.26px,299.67px 196.53px,259.33px 209.53px,217.00px 254.76px);
    }    

Мы также можем определить вышеупомянутую форму используя изображение с альфа-каналом. Картинка ниже показывает как это изображение будет выглядеть. И снова черная область определяет область в которой текст будет находится текст когда мы используем свойство `shape-inside`. 
<figure>

![][32]

Если вы хотите использовать image URI вместо функции формы вы должны заменить значение формы следующим кодом: 

    .container{
      /*...*/
      shape-inside: url(mask.png) top left;
    }           


### Пример 4: Множественные области с `shape-inside` 

В этом примере мы сообираемся создать множественные области внутри элементов в которых заключим контент. Результирующее демо показано на нижеследующем рисунке: 

![][33]

Мы имеем `div` с фоновым изображением и мы хотим поместить текст внутрь `div` 

    <div class="container">
      <div class="content">
          <h2>Rosemary Sandwich</h2>
          <p>…</p>
      </div>
    </div>      

Теперь так как мы не можем объявить множество форм на элементе мы будем использовать изображение с альфа-каналом. Изображение может содержать любое количество форм и областей, поэтому оно идеально определяет множество форм элемента, браузер извлекает все формы из изобржения и использует их на элементе. Мы будем использовать следующее изображение для определения форм. Черные области на картинке будут определять области для контента внутри `.container` где будет содержаться текст. 

![][34]

В определении `.container` в значение `shape-inside` свойства мы подставим наше изображение с альфа-каналом, и не забудем указать высоту и ширину блоку:

    .container{
      width:556px;
      height:835px;
      overflow:hidden;
      margin:0 50px;
      color:white;
      position:relative;
      background: url(../images/bread.jpg) top left no-repeat;
      background-size: 100% 100%;
      shape-inside: url(mask.png) top left;
      font-size:13px;
    }          

Вот мы и закончили. Оставшуюся работу сделал за нас браузер — достав формы из изображения что мы ему дали и аккуратно расположив текст внутри этих форм.

Использовать изображения для определения форм вполне логично когда вы имеете раздельные области не соеденинные друг с другом, то есть когда нельзя сформировать многоугольник. Для следующего демо мы могли бы использовать функцию `polygon()` для определения формы, определение многоугольника выглядело бы следующим образом:

![][35]

Но как вы уже успели заметить это не лучшая идея. Я просто показала ее вам чтобы вы могли увидеть разницу между использованием изображений и определением форм через `polygon()`, а также что иногда «лучшая практика», а иногда и единственная, которая довольна проста и имеет больше смысла - это использовать изображение, даже если вы можете построить функцию для определения формы.  


## Комбинирование CSS-форм с Regions и Flexbox для создания журнальных макетов 

Типичные издания журнланов используют комбинацию много-колоночного текста с непрямоугольными формами для создания креативного и привлекательного дизайна. Колонки обычно одинаковой высоты, если не требуется обратного.

После того как будущие возможности CSS-форм будут реализованы и обварачивание контента с двух сторон формы станет возможным, создание макетов наподобии печатных журналов станет очень реальным и тогдаы мы сможем комбинировать формы и исключения с Регионами и Флексбоксами.

[![][36]][37]

Флексбоксы дают нам столбцы одинковой высоты, Регионы позволяют размещать текст в разных областях страницы и разделять содержимое страницы от его расположения, Формы и Исключения позволят нам добавить финальный штрих что перенесет журнальную верстку на новый уровень. 


## Финальные слова

Еще не одна CSS фича не вызывала во мне столько восторга как CSS-формы и исключения. Мощность, гибкость и разнообразние которые предоставляют новые возможности в сочетании с Регионами и Флекбоксами просто потрясают.

В скором времени должна появиться широкораспространенная поодержка CSS-форм, команда веб-разработчиков из Adobe постоянно работают над улучшением и внедрением новых возможностей, а также предоставляют инструменты для работы с ними. 

Будущее веб разработки выглядит все ярче и привлекательней с каждым днем. Самое время быть веб разработчиком! Я надеюсь что эта статья поможет войти вам в технический курс дела относительно CSS-форм и Исключений. Это не последняя моя статья на эту тему. Комбинирование CSS-форм с другими передовыми технологиями мира CSS такими как Регионы открывает двери в новый мир творческих идей и создания новых статей! ;)


[1]: http://css-tricks.com/examples/ShapesOfCSS/
[2]: http://blogs.adobe.com/webplatform/2013/10/23/css-shapes-visual-storytelling/
[3]: https://src.chromium.org/viewvc/blink?revision=159989&view=revision
[4]: http://html.adobe.com/webplatform/enable/
[5]: http://www.w3.org/TR/2007/WD-css3-box-20070809/
[6]: http://blogs.adobe.com/webplatform/2014/02/11/new-css-shapes-syntax/
[7]: http://www.w3.org/TR/css-shapes/#CSS3BOX
[8]: http://www.w3.org/TR/css-shapes/
[9]: img/shape-background.png
[10]: img/box-model-background.png
[11]: https://dvcs.w3.org/hg/FXTF/raw-file/default/masking/index.html
[12]: http://codepen.io/SaraSoueidan/pen/ad12e1280e4b1c481faa3b82bd9a3263
[13]: img/shapes_CSS2.1_MBP.png
[14]: http://betravis.github.io/shape-tools/exclusion-punch/
[15]: https://twitter.com/bear_travis
[16]: img/demo-screenshot1.png
[17]: http://sarasoueidan.com/blog/css-shapes/demo-1/index.html]
[18]: img/demo-shape.png
[19]: img/demo-screenshot-incomplete.png
[20]: img/mask.png
[21]: img/demo-screenshot2.png
[22]: http://sarasoueidan.com/demos/css-shapes-layouts/demo-2/index.html
[23]: img/demo-shape1.png
[24]: img/mask1.png
[25]: img/demo-screenshot3.png
[26]: img/demo-shape2.png
[27]: https://twitter.com/bear_travis
[28]: http://betravis.github.io/shape-tools/
[29]: http://betravis.github.io/shape-tools/polygon-drawing/
[30]: https://twitter.com/razvancaliman
[31]: https://www.youtube.com/watch?v=zsLwZhTSuQk&list=PL8rji95IPUUDu3puqqxWMKFXf-NQ4z7WE&index=11
[32]: img/mask2.png
[33]: img/demo-screenshot4.png
[34]: img/mask3.png
[35]: img/demo-shape3.png
[36]: img/multicolumn-shapes.png
[37]: http://www.behance.net/gallery/Travel-Magazine/2159303

















