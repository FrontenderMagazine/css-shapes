<section class="main post-wrapper clearfix">
Сегодня мы можем создавать любые виды форм при помощи [css-трансформаций][1], но эти формы не могут влиять на контент внутри них или вокруг них. Например, если вы создаете треугольник или трапецию средствами css, то созданная форма не определяет и не влияет на поведение текста внутри нее или же на поведение текста снаружи нее.

С введением css форм в веб завернуть контент в пользовательскую непрямоугольную форму или же воссоздать типографические(печатные) проекты и макеты в вебе стало проще простого.

В этой статье мы собираемся перейти к описанию базовых форм и созданию простых макетов с использованием новых css технологий. Когда большинство css форм будет внедрено, тогда все больше сложных и *разнообразных* макетов будет доступно, но даже с тем что мы имеем сейчас на руках несколько [инетересных макетов] [2] может быть создано, если слегка поэксперементировать.

**Css технологии о которых мы будем рассказывать в этой статье являются передовыми и не все браузеры их поддерживают. Если вы хотитеть увидеть работающие живые демонстрации кода, тогда вы должны убедиться, что смотрите на них в браузерах, которые поддерживают эти технологии.
Хотя вам совсем и не обязательно нужны эти браузеры, чтобы понять все идеи и код. Я вставила скриншоты демо-версий так что вы сможете увидеть как выглядит финальный результат.**

На тот момент, когда я писала статью, только Chrome Canary [поддерживал непрефиксированую версию css форм][3], но все еще нуждается во флаге. Убедитесь что вам [доступны возможности css форм][4], чтобы смотреть на работающие демки.

Пожалуйста учтите, что часть информации упоминаемая в этой статье может быть изменена, когда поддержка цсс форм будет увеличена(расширена) и многие возможности этой спецификации будут реализованы. 

### Объявление формы.

Все html элементы имеют прямоугольную блочную модель, которая регулирует поток внутри и снаружи нее. Для того чтобы придать элементу пользовательскую непрямоугольную форму мы используем свойства: `shape-inside` и `shape-outside`. Во время того как я писала эту статью свойство `shape-outside` применялось только для float элементов, а свойство `shape-inside` не было полностью внедрено, поэтому используя эти свойства у вас могут возникать ошибки.
Shape-свойства могут применяться только к блочным элементам. Неблочные элементы должны приводиться стилями к блочным и только тогда можно использовать shape-свойства.

Shape- *свойства берут одно из трех значений: auto, базовая фигура или image URI.
Если свойство установлено в auto, то зона плавающего элемента (плавающие элементы реагируют на  margin в обычном режиме). Если вы не знакомы с [Css box model][5] рекомендую ознакомиться, потому что вам необходимо знать как это работает.

Если свойство установлено в "shape function", то фигура вычисляется на основе значений одной из списка функций - ‘`rectangle`’, ‘`inset-rectangle`’, ‘`circle`’, ‘`ellipse`’, ‘`polygon`’. Вы можете узнать намного больше об этих функциях в [статье][6] от Adobe Platform team. 

И наконец-то, если свойство установлено в image URI - браузер будет использовать изображение для извлечения и вычисления формы основанной на альфа-канале изображения. Форма вычисляет путь, который охватывает область где непрозрачность указаного изображения больше чем `shape-image-threshold` значение. Если `shape-image-threshold` не указано, то начальное значение будет установлено 0.5. Изображение должно быть CORS-same-origin, в противном случае оно не будет работать и значение `auto` автоматически будет значением вычесленой формы.

Формы определенные при помощи `shape-outside` свойства определяют *область исключения* на элементе, а те которые определены с помощь свойства `shape-inside` определяют *плавающую область* на элементе.
Мы узнаем, что это означает в примерах ниже. 

Формы определеные при помощи shape-* свойств могут быть изменены при помощи `shape-margin` and `shape-padding`. Эти свойства говорят сами за себя.

### Создание системы координат на элементе.

Чтобы использовать цсс формы на элементах, мы сначала должны установить систему координат которая будет использоватьсяд для рисования форм/фигур.

Система координат обязательнат так как фигуры которые ты описываешь будет определена через набор точек(и радиусов если ты будешь рисовать круги или элипсы, например) и эти точки иметют кооридинаты x and y, которые распологаются на координатной оси.

The shape-* properties используют контейнер содержимого элемента и применяют к ним систему координат, поэтому для того чтобы заставить их работать вам нужно указать фиксированную ширину и высоту для элемента, которые определяет границы, которые в свою очередь будут использоваться для установления системы координат для отрисовки фигур. **Если явно ширина и высота не указаны свойства фигур работать не будут.**

The origin of the coordinate system defined on the element's bounding box is
positioned at the top left corner.

So, to declare a shape an element you have to start with: 

1.  Specifying the dimensions of the element getting the shape (remember: the
    element should be floated when using
   `shape-outside` on it).
2.  Declaring the shape on that element using the shape-* properties.

### Применение фона к настраиваемым элементам

>"Когда(В то время как) границы используются для обварачивания содержимого потока 
>вне ..."

> While the boundaries used for wrapping inline flow content outside a float
> can be defined using shapes,
>**the actual box model does not change**. If the element has specified margins
> , borders or padding they will be computed and rendered according to the
>[CSS3BOX][7] module. —[W3C CSS Shapes Module Level 1][8] 

Другими словами, фигура определеная на элементе используя shape-* свойства влияет *только* на плавающую площадь элемента, то есть поток внутри и снаружи элемента, но все другие свойства не изменяются.

Например, предположим что вы хотите нарисовать круглую фигуру и имеете отбтекающий контент в виде фигуры, как на рисунке ниже, сначала вы объявили круглую фигуру на элементе(напоминаю, что плавающему элементу нужно задать высоту и ширину). Потом скажите, что вы хотите применить цветной фон к круглой фигуре чтобы она выглядиела как на картинке.. 

[картинка]
<figure>![Background applied to CSS shape][9]<figcaption>Фон применен к заданой пользователем форме</figcaption></figure>

Вы желали просто добавить фон для содержащего элемента, а затем в конечном итоге результат выше. (то что я сделал в первый раз), но делая так мы не делаем работу. Причина этому в том что все свойства элемента, кроме потока за ее пределами, не будет зависеть от формы заданой внутри него и они будут предоставляться в обычном режиме согласно блочной модели элементов(прямоугольные фигуры) как мы видели в спификации. Так что если вы примените цвето фона к нему, вы получите в итоге цвет фона и у него.

[картинка 2]
<figure>![Background applied to rectangular box model][10]<figcaption>Фон применятеся к форме прямоугольной коробки элемента</figcaption></figure>

*Как мы можем применять цвет только к фигуре не ко всему элементу сразу?* Вот где свойство `clip-path` из [css-спецификации][11] может помочь.

Свойство `clip-path` используется для *отрезания* части элемента которая нам не нужна и оставлять только те части внутри фигуры, которые мы определели. Это очевидно означает что мы на самом деле не применяли цвет к фигуре, мы только *обрезали* элемент и оставляли нетронутой фигуру. 
При этом вы будете с обтекающим круг обрамлющий текст вокруг нее. 

*Каким образом? Какое значение для свойства clip-path заставляет это работать?*

Пользовательская система координат для фигур определяется при помощи свойства `clip-path` она устанавливается используя границы элемента для которых обрезающий путь был применен, поэтому система координат аналогична для shape-* свойств.

Благодаря этому мы можем использовать ту же фигуру определенную в shape-* свойстве для обрезающего пути, которая будет обрезана или вырезать все внутри содержащего элемента что снаружи границ фигуры в результате мы получим настраиваемую фигуру с фоном. 

Вы можете протестировать эту идею [в живую][12], только убедитесь что вы тестируете в поддерживающем браузере (Chrome canary at the moment).

### Краткое(быстрое) напомнинание.

На момент редактирования статьи свойство `shape-outside` работало только на плавающих элементах, а оба свойства `shape-outside` и `shape-inside` применялись только к блочным элементам или же к инлайновым элементам *приведенным к блочным*.
Фигура определенная, как плавающая будет использовать инлайновый контент для обертки вокруг определенной фигуры вместо плавающего bounding box. Будущие уровни Цсс форм будут разрешать использование фигур на элементах отличных от плавающих. и когда это случится мы сможем оборачивать контент с двух сторон формы.(как на картинке ниже). Но пока что мы можем только обтекать элемент и иметь обтекающий контент с двух сторон его. 

<figure>![Example rendering of circle shape and box model.][13]<figcaption>Расположение контента с двух сторон от CSS-формы</figcaption></figure>

Вы так же можете поддельно упаковать контент с двух сторон используя 
[Exclusion Punch plugin][14] by [Bear Travis][15].

А теперь двавайте испачкаем наши руки нарисуя пару форм и создавав несколько веселых макетов!

Каждый из следующих примеров представляет собой новую подсказку/идею/технику, которая используется для определения и использования цсс форм и исключений. 

**Вы можете посмотреть живое демо для каждого примера просто кликнув на скриншот**


### Пример 1: Плавающий текст вокруг пользовательской формы с `shape-outside` 
Мы начнем с простого примера. В этом примере мы собираемся определить пользовательскую форму и контент обтекающий с нужной стороны. Результат будет выглядеть как на кантинке ниже:

[ <figure>![Screenshot of Demo #1][17]<figcaption>Скриншот демо #1</figcaption></figure>][17]

В демо примере мы имеем два элемента: `.content` - контейнер с текстом слева и другой элемент `.shaped` зафлоаченый вправо, который получит собственную форму и будет иметь огибающий слева текст. 
Заголовок `.content` получает такое же поведение которое мы дали диву зафлоченому направо. 
Поэтому я пропущу объяснения и буду рассказывать только про что мы делаем с пространством `.shaped` справа.

    <div class="container">
                      <div class="shaped"></div>
                      <div class="content">
                        <h1><span>La</span> Tour <br/>Eiffel</h1>
                        <p>Lorem Ipsum......</p>
                      </div>
                    </div>
                  


Сперва мы зададим плавающему элементу `div` конкретную высоту и ширину для установки системы координат. 
Мы установим высоту равную высоту контейнера, которому для этого примера я установила высоту вьюпорта используя css `vh` блок. 

    .container{
                      overflow:hidden;
                      height: 100vh;
                      width: 100vw;
                    }
                    .shaped{
                      float:left;
                      height:100vh;
                      width:40vw;
                      float:right;
                      background: black url(../images/eiffel.jpg) center top no-repeat;
                      background-size:cover;
                    }
                  


Сейчас, когда система координат готова, мы собираясь рисовать фигуру, определим плвающие участки и исключения элемента. Тут два пути объявления фигуры для этого примера:

### Использование `polygon()`
Для первого метода мы будем использовать функцию polygon(). 
Данная функция принимает набор точек, которые образуют прямоугольник, каждая точка задается через координаты x и y.  
Мы собираемся определить очень простую прямоугольную фигуру с 4 вершинами, как показано на рисунке ниже (оранжевые и голубые точки):

<figure>![Vertices of the Polygon][17]<figcaption>Screenshot showing the vertices
making up the polygonal shape</figcaption></figure>
[рисунок:
Скриншот показывает вершины, которые образуют прямоугольную фигуру.
Скриншот показывает вершины, составляющие форму многоугольника
]

Координаты точек могут иметь либо конкретные значения(px или em) или процентные значения. 
В этом примере мы собираемся предоставить процентные значения для вершин. 
Сейчас все что мы должны сделать это объявить фигуру на плавающем элементе так что текст обступал его с этой стороны.

    .shaped{
      /*...*/
      shape-outside: polygon(0 0, 100% 0, 100% 100%, 30% 100%);
      shape-margin: 20px;
    }
                  


И это все! Теперь текст может обтекать *float area* элемента, по специальной форме, которую мы определили.

Также вы можете видеть, что я добавила margin фигуре, чем отдалила содержимое от фигуры на немного и создала промежуток между ними. 

Но нужно добавить кое-что еще. Как я упоминала в предыдущей главе фон плавающего элемента применяется к оригинальной прямоугольной фигуре, не к фигуре определенной на ней, потому что свойство фона не распосраняется на фигуру определенную на элементе. В демке это вы глядит так: <figure>![Screenshot of background applied to rectangular shape of the element][18]<figcaption>Скриншот на котором фон заполняет прямоугольную форму элемента</figcaption></figure>

Поэтому мы вырезаем лишнюю часть используя свойство `clip-path` и дадим тоже значение/форму что мы дали свойству `shape-outside` выше. Мы добавим это правило в набор правил: 

    .shaped{
      /*...*/
      clip-path: polygon(0 0, 100% 0, 100% 100%, 30% 100%);
    }
                  

Вот мы и закончили! Легко, не правда ли?

Заголовок страницы слева имеет такую же обработку как и `.floated` `div` справа.
Заголовок страницы справа имеет такое же поведение как и див с классом .floated обтекающий справа.  
Загаловок плавает внутри контейнера .content, он дает конкретную высоту и ширину для установки системы координат, и затем фигура уставливается на нем используя свойство `shape-outside` также как мы это делали для элемента `.floated`.

### Использование image URI

Другой способ, которым мы можем определять формы на элементах это использовать изображения с альфа-каналом, то есть любые изображения с прозрачностью.
 
Для примера, вместо использования функции polygon() для определения фигуры, мы дадим в свойству `shape-outside` image URI, и браузер достанет фигуру из изображение и использует ее.

Образ который будет определять область исключения для этого примера представлен ниже. 
Вы можете заметить что фигура повторяет фигуру созданную с помощью функции polygon() из точек примером выше. <figure>

![Image with Alpha Channel showing the polygonal shape][19]<figcaption>Image
with Alpha Channel whose URI will be used to extract and compute the value of 
the shape</figcaption></figure>

Когда мы используем изображени с альфа каналом для задания фигуры через свойство shape-outside, прозрачная область изображения будет определять область где текст будет обрамлять фигуру, это область будет называться *плавающей областью* элемента. Черная часть определяет область исключения элемента. 

Для использования изображения мы напишем следующее: 

    .shaped{
                    /*...*/
                    shape-outside: url(../images/mm.png);
                    shape-image-threshold: 0.5;/* this property is used to set the threshold used for extracting a shape from an image. 0.0 = fully transparent and 1.0 = fully opaque */
                  }
       

Каждый из указанных двух методов имеют свои преимущества. Возможно вы захотите использовать изображения с альфа каналом для сложных фигур где могло бы быть затруднительно (громоздко) создавать точки вручную, в этом случае создание изображения в Фотошопе будет намного проще и быстрее чем добавление точек руками.

Другая ситуация когда вы можете захотеть использовать image URI вместо функции формы - это когда у вас много плавающих или исключающих областей в элементе, в этом случае использование этого метода обязательно потому что вы не можете, пока что, объявлять несколько форм на одном элементе, но если изображение имеет много областей браузер извлечет эти области из изображения и будет использовать их. 
Неплохо, правда? 
Мы можем посмотреть пример такого случая в последнем демо. 

### Пример 2: обворачивание/обтекание текста внутри пользовательской формы при помощи `shape-inside`

Для второго примера мы создадим простую демонстрацию где окончательный результат будет выглядеть вот так: 
[ <figure>![Screenshot of demo #2][21]<figcaption>Screenshot of demo #2</figcaption></figure>][21]
Цель этого примера показать использование свойства 
The goal of this example is to demonstrate the  в непрямоугольной форме. 
Мы имеем контейнер с несколькими заглушками текста внутри него и мы применяем фотографию как фоновое изображение этому контейнеру.

    <div class="container">            
                      <div class="content">
                          <p>...</p>
                      </div>
                      <h2>Corn Bread</h2>
                    </div>
                

Как вы можете видеть на скриншоте демки выше текст находится внутри округлой формы вверху. Значит мы знаем что мы будем объявлять круг на нашем контейнере. Сейчас как и в предыдущем примере у нас есть два способа как это можно сделать.

#### Использование `circle()` 

Функция circle() имеет три аргумента: cx, cy и r (радиус), где cx и cy координаты центра окружности и r - это радиус окружности. 

Изображение ниже показывает, что система координат установлена на элементе и  окружность находится внутри элемента. Мы можем удостовериться, что окружность установлена сверху на изображении сковороды, что на фото, которое мы используем как фоновое изображение, так что кажется что текст содержится внутри сковородки. 
На картинке так же видно, что центр окружности установлен по отношению к системы координат на элементе. 
<figure>

![Coordinate system and shape defined on the container][17]<figcaption>
Coordinate system and shape defined on the container</figcaption></figure>
Так как мы хотим обвернуть текст *внутри* пользовательской формы и не обеткать его вокруг мы собираемся использовать свойство `shape-inside` к элементу который содержит этот текст. Когда мы применяем свойство `shape-inside` к элементу мы должны помнить что этот элементе должен иметь текст внутри себя, что не похоже на  предыдущий пример, где контент был снаружи элемента на котором мы определяли форму. 

Мы укажем координаты центра окружности в абсолютных величинах в этот раз, не в процентах, и установим значение радиуса и применим это все к контейнеру: 

    .container{
                      float:left;
                      width:600px;
                      height:900px;
                      overflow:hidden;
                      margin:0 50px;
                      color:white;
                      font-size:13px;
                      padding:10px;
                      background: url(../images/pan.jpg) top left no-repeat;
                      background-size:100% 100%;
                      /*declare shape using the shape function circle()*/
                      shape-inside: circle(400px, 60px, 160px);
                    }

Конечно, если вы не пытаетесь создать окружность идеальной формы вы так же можете определить форму при помощи функиции`polygon()`.

#### Использование image URI

Мы так же можем использовать URI изображения с альфа-каналом чтобы достать форму окружности из нее. Картинка будет выглядеть следующим образом: 
<figure>

![Image with Alpha Channel showing the circular shape
              ][19]<figcaption>Image with Alpha Channel defining the circular
shape</figcaption></figure>
Очень важно отметить здесь что когда мы используем изображения с альфа-каналом для определения формы **со свойством `shape-inside`** *черная(или непрозрачная) область* изобржения будет определять область где будет находится текст. В прошлом примере непрозрачная область определяла *область исключения* элемента на которого мы применили форму, т.е. область где нет текста. 

Объявляя форму используя image URI вместо функции `circle()` вы должны будете указать в значение свойства `shape-inside` ссылку на image URI.   

    .container{
                      /*...*/
                      shape-inside: url(mask.png) top left;
                    }
                  

### Пример 3 : обварачивание/обтекание текста внутри пользовательской формы при помощи `shape-inside`

В этом примере мы также объявим многоугольную форму на контейнере и зададим контент внутри этой формы. Конечный результат будет выглядить вот так:

[ <figure>![Screenshot of Demo #3][22]<figcaption>Screenshot of Demo #3</figcaption></figure>][22]

В данном случае мы так же можем использовать функцию для описания формы или изображение с альфа-каналом.

Форма, объявленая для этого контейнера, -- это явно "случайная" многоугольная форма, а не геометрическая форма, которую можно было объявить, используя функции форм вроде `circle()`, `ellipse()` или `rectangle()`, поэтому для ее объявления мы будем использовать функцию `polygon()`. 

На рисунке снизу показана форма, задаваемая набором точек. <figure>

![The polygonal shape defined by a set of points][17]<figcaption>The polygonal
shape defined by a set of points</figcaption></figure>

Так как эта форма задается довольно большим количество точек вычислять их координаты было бы утомительно, поэтому было бы намного проще, если бы существовал *визуальный* инструмент, который помог бы расставить точки на изображении, правда ведь? И такой инструмент существует и создан [Bear Travis][15] из Adobe,  и на самом деле это набор инструментов который поможет вам при работе с CSS-формами.
Обязательно посмотрите на [Shape Tools][22] потому что они очень полезны.

Один из инструментов Shape tools называется [Poly Draw][23] и он позволяет вам вручную рисовать форму, многоугольник в частности и затем он генирирует координаты формы, которые вы можете скопировать и вставить в свой CSS чтобы задать форму элемента.  

Я использовала инструмент Poly Draw для того что нарисовать форму изображеную на рисунке сверху. 
Now, the
tool does not take an image and sets it as a background for the element you 
define the shape on, so I had to git clone the repo of the tool and fiddle with 
the tool’s code a bit in the dev tools, and I applied the image to it and 
plotted the points on it.

[Razvan Caliman][24] предложил эту идею, когда я спросила его о доступности инструмента, который позволял определять формы на картинке прямо в браузере, такого же как и тот что он показывал на [его выступлении на CSS конференции][25].
Если вы еще не видели то обязательно посмотрите. Исходиники этого инструмента оджнажы, очень надеюсь, что скоро будут открыты компанией Adobe и тогда этот инструмент станет незаменимым при работе с CSS-формами. Ну, а пока можно обходиться инструментом Poly Draw.

После того как нарисовали форму при помощи Poly Draw все что вам нужно это объявить результрующую форму элемента и это все. 

    .container{
                    width:445px;
                    height:670px;
                    overflow:hidden;
                    margin:30px auto;
                    /*shape generated by the Poly Draw tool*/
                    shape-outside: polygon(170.67px 291.00px,126.23px 347.56px,139.79px 417.11px,208.92px 466.22px,302.50px 482.97px,343.67px 474.47px,446.33px 452.00px,443.63px 246.82px,389.92px 245.63px,336.50px 235.26px,299.67px 196.53px,259.33px 209.53px,217.00px 254.76px);
                  }
                

Мы также можем определить вышеупомянутую форму используя изображение с альфа-каналом. Картинка ниже показывает как это изображение будет выглядеть. И снова черная область определяет область в которой текст будет находится текст когда мы используем свойство `shape-inside`. 
<figure>

![Image with alpha channel defining the shape for demo #2][19]<figcaption>Image
with alpha channel defining the shape for demo #2</figcaption></figure>

Если вы хотите использовать image URI вместо функции формы вы должны заменить значение формы следующим кодом: 

    .container{
                    /*...*/
                    shape-inside: url(mask.png) top left;
                  }
                

### Пример 4 : Множественные области с `shape-inside` 
В этом примере мы сообираемся создать множественные области внутри элементы в которых заключим контент. Результирующее демо показано на нижеследующем рисунке: 

[ <figure>![Screenshot of Demo #3][27]<figcaption>Screenshot of Demo #3</figcaption></figure>][27]
Мы имеем `div` с фоновым изображением и мы хотим поместить текст внутрь `div` 

    <div class="container">
                    <div class="content">
                        <h2>Rosemary Sandwich</h2>
                        <p>...</p>
                    </div>
                  </div>
                

Теперь так как мы не можем объявить множество форм на элементе мы будем использовать изображение с альфа-каналом. Изображение может содержать любое количество форм и областей, поэтому оно идеально определяет множество форм элемента, браузер извлекает все формы из изобржения и использует их на элементе.
Мы будем использовать следующее изображение для определения форм. Черные области на картинке будут определять области для контента внутри `.container` где будет содержаться текст. 
<figure>

![Image with Alpha Channel defining shapes for demo #3][19]<figcaption>Image
with Alpha Channel defining shapes for demo #3</figcaption></figure>

We'll use the URI of this image as a value for the `shape-inside` property that
we're going to declare on the`.container`, all the while remembering to set
height and width values for the`div`:


    .container{
                    width:556px;
                    height:835px;
                    overflow:hidden;
                    margin:0 50px;
                    color:white;
                    position:relative;
                    background: url(../images/bread.jpg) top left no-repeat;
                    background-size: 100% 100%;
                    shape-inside: url(mask.png) top left;
                    font-size:13px;
                  }
                

Вот мы и закончили. Оставшуюся работу сделал за нас браузер - достав формы из изображения что мы ему дали и аккуратно расположив текст внутри этих форм.

Использовать изображения для определения форм вполне логично когда вы имеете раздельные области не соеденинные друг с другом, то есть когда нельзя сформировать многоугольник. Для следующего демо мы могли бы использовать функцию `polygon()` для определения формы, определение многоугольника выглядело бы следующим образом:
<figure>

![Image of shape defined using polygon()][17]<figcaption>Image representing the
points used to define a single polygon</figcaption></figure>

Но как вы уже успели заметить это не лучшая идея. Я просто показала ее вам чтобы мы могли увидеть разницу между использованием изображений и определением форм через `polygon()`, а так же что иногда "лучшая практика", а иногда и единственная, которая довольна проста и имеет больше смысла - это использовать изображение, даже если вы можете построить функцию для определения формы.  

### Комбинирование CSS-форм с Regions и Flexbox для создания журнальных макетов 

Типичные издания журнланов используют комбинацию много-колоночного текста с непрямоугольными формами для создания креативного и привлекательного дизайна. Колонки обычно одинаковой высоты, если не требуется иного.

После того как будущие возможности CSS-форм будут реализованы и обварачивание контента с двух сторон формы станет возможным, создание макетов наподобии печатных журналов станет очень реальным когда мы сможем комбинировать формы и исключения с Регионами и Флексбоксами.

[ <figure>![Multi-column layouts with shapes][28]<figcaption>Travel Magazine by Bartosz Kwiecień on Behance. Layout like this could be replicated using future CSS Shapes technologies and Regions</figcaption></figure>][28]

Флексбоксы дают нам столбцы одинковой высоты, Регионы позволяют размещать текст в разных областях страницы и разделять содержимое страницы от его расположения, Формы и Исключения позволят нам добавить финальный штрих что перенесет журнальную верстку на новый уровень. 

### Финальные слова

Еще не одна CSS фича не вызывала во мне столько восторга как CSS-формы и исключения. Мощность, гибкость и 
Я не думала что буду в таком восторге от новых CSS возможностей, в каком нахожусь
I don’t think I’ve been excited about a new CSS feature as I am about CSS
shapes and exclusions. The power, flexibility, and creativity that these 
features combined regions and flexbox can provide is just fantastic!

В скором времени должна появиться широкораспространенная поодержка CSS-формам 
Widespread support for CSS Shapes should be coming soon, as the web platform
team at Adobe is constantly working on improving and implementing these features,
and providing tools to make working with them easier.

Будущее веб верстки выглядит все ярче и привлекательней с каждым днем. Самое время быть веб разработчиком!

The future of web layout is looking brighter and more captivating every day. It
's a wonderful time to be a web developer!
Я надеюсь что эта статья поможет войти вам в технический курс дела относительно CSS-форм и Исключений. Это не последняя моя статья на эту тему. Комбинирование CSS-форм с другими передовыми технологиями мира CSS такими как Регионы открывает двери в новый мир творческих идей и создания новых статей! ;)
I hope this article helped introduce you more to the technical part of getting
started with CSS Shapes and Exclusions. This will not be my last article on this
topic. Combining CSS Shapes with other cutting edge CSS technologies like 
Regions opens the door to a new world of creativity, and lots of new tutorials!
;)

Вы можете подписаться на мой блог и фолловить меня в твиттере. 

Спасибо за внимание! 

You should subscribe to my blog's [RSS feed][28] and [follow me on Twitter][29]

Thank you for reading!

















