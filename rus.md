# Создание непрямоугольных макетов при помощи CSS-форм

Сегодня вы можете создавать любые [виды форм][1] при помощи CSS-трансформаций, но эти формы не могут влиять на поведение содержимого внутри них или вокруг них. Например, если вы создаете треугольник или трапецию посредством CSS, то созданная форма не определяет и не влияет на то, как будет вести себя текст внутри фигуры или вне ее.

С появлением CSS-форм в вебе стало проще обернуть контент в пользовательскую непрямоугольную форму или же воссоздать типографические (печатные) проекты и макеты.

В этой статье я собираюсь перейти к описанию базовых форм и созданию простых макетов с использованием новых CSS-технологий. Когда большинство CSS-форм будет внедрено, тогда все больше сложных и *разнообразных* макетов будет доступно, но даже с тем, что мы сейчас имеем, можно создать несколько [интересных макетов][2], нужно всего лишь поэкспериментировать.

**CSS-технологии, о которых я буду рассказывать в этой статье, являются передовыми, и не все браузеры их поддерживают. Если вы хотите увидеть работающие живые демонстрации кода, тогда вы должны убедиться, что смотрите в браузерах, которые поддерживают эти технологии.
Хотя вам совсем и не обязательно нужны эти браузеры, чтобы понять идею или код. Я вставила скриншоты демо-версий, так что вы сможете увидеть, как выглядит финальный результат.**

На тот момент, когда я писала статью, только Chrome Canary [поддерживал версию CSS-форм без префиксов][3], но для этого его надо запускать со специальным флагом. Убедитесь, что вам [доступны возможности CSS-форм][4], чтобы смотреть на работающие демонстрации.

Пожалуйста, учтите, что часть информации, упоминаемая в этой статье, может быть изменена, когда поддержка CSS форм будет увеличена (расширена), и многие возможности этой спецификации будут реализованы. 


## Объявление формы

Все HTML-элементы имеют прямоугольную блочную модель, которая регулирует поток внутри и снаружи нее. Для того, чтобы придать элементу пользовательскую непрямоугольную форму, мы используем свойства `shape-inside` и `shape-outside`. Во время того как я писала эту статью, свойство `shape-outside` применялось только для плавающих элементов, а свойство `shape-inside` не было полностью внедрено, поэтому при использовании этих свойств у вас могут возникать ошибки.
Shape-свойства могут применяться только к блочным элементам. Неблочные элементы должны приводиться стилями к блочным, и только тогда можно использовать shape-свойства.

Shape-* свойства принимают одно из трех значений: auto, базовая фигура или image URI.
Если свойство установлено в auto, то плавающие элементы используют margin box в обычном режиме. Если вы не знакомы с [CSS box-model][5], то рекомендую ознакомиться, потому что вы должны знать, как это работает.

Если свойство установлено в «shape function», то форма вычисляется на основе выбора одного из значений функций - `rectangle`, `inset-rectangle`, `circle`, `ellipse`, `polygon`. Вы можете узнать намного больше об этих функциях в [статье][6] от команды Adobe Platform.

И наконец, если свойство установлено в image URI, браузер будет использовать изображение для извлечения и вычисления формы, основанной на альфа-канале изображения. Форма вычисляет путь, который охватывает область, где непрозрачность указаного изображения больше, чем значение параметра `shape-image-threshold`. Если параметр `shape-image-threshold` не указан, то начальное значение будет установлено в `0.5`. Изображение должно быть CORS-same-origin, в противном случае оно не будет работать, и значение автоматически установится в `auto`.

Формы, определенные при помощи свойства `shape-outside`, определяют *область исключения* на элементе, а те, которые определены с помощь свойства `shape-inside`, определяют *плавающую область* на элементе. На примерах, приведенных ниже, мы узнаем, что это означает.

Формы, определеные при помощи свойств shape-*, могут быть изменены при помощи `shape-margin` и `shape-padding`. Эти свойства говорят сами за себя.


## Создание системы координат на элементе.

Чтобы использовать CSS-формы на элементах, вы сначала должны установить систему координат, которая будет использоваться для рисования форм/фигур.

Система координат обязательна, так как формы, которые вы задаете, будут определены через набор точек (и радиусов, если рисовать круги или элипсы), и эти точки имеют кооридинаты x и y на координатной оси.

Свойства shape-* используют контейнер содержимого элемента и применяют к нему систему координат, поэтому вам нужно указать фиксированную ширину и высоту для элемента, которые определяют границы, которые, в свою очередь, будут использоваться для установления системы координат для отрисовки фигур. **Если ширина и высота явно не указаны, свойства фигур работать не будут.**

Центр системы координат устанавливается в верхний левый угол.

Итак, для задания формы на элементе вы должны сначала: 
1. Задать конкретные значения элементу (помните, что он должен быть плавающим, если вы используете `shape-outside`).
2. Использовать свойства shape-*.


### Применение фона к настраиваемым элементам

>В то время как мы можем ограничивать строчный контент с помощью shapes (форм) реальный его контейнер не изменится. Если элемент имеет конкретные внешние и внутренние отступы, границы, то они будут расчитаны в соотвествии с [CSS3BOX][7]. — [W3C CSS Shapes Module Level 1][8] 

Другими словами, форма, определенная на элементе с помощью свойств shape-*, влияет *только* на плавающую площадь элемента, то есть на поток внутри/снаружи элемента, но остальные свойства не изменяются.

Например, предположим, что вы хотите нарисовать круглую форму с обтекающим контентом, как на рисунке ниже. Сначала вам нужно объявить круглую форму на элементе (не забудьте, что элемент должен быть плавающим, и ему нужно задать высоту и ширину). Затем, предположим, вы захотите применить цветной фон, чтобы форма выглядела как на картинке...

![Фон применен к заданой пользователем форме][9]

Вам хочется просто указать фон содержащему элементу, чтобы результат бы таким как на картинке выше (я так и сделала в первый раз), но это не сработает. Дело в том, что все свойства элемента, кроме потока за его пределами, не зависят от формы заданой внутри него, и они будут отрисовываться в обычном режиме согласно блочной модели элементов (прямоугольной формы), как мы читали в спефикации выше. Так что, если вы примените цвет фона к элементу, то...

![Фон применяется к форме прямоугольной коробки элемента][10]

*Как же применить цвет только к форме, а не ко всему элементу сразу?* Вот где свойство `clip-path` из [CSS-спецификации][11] может помочь.

Свойство `clip-path` используется для *отсечения* частей элемента, которые нам не понадобятся. Очевидно, что это означает, что мы не применили цвет к форме, а только *обрезали* элемент и оставили нетронутой форму. При этом текст будет обтекать круг.

*Каким образом? Какое значение свойства clip-path заставляет так работать?*

Пользовательская система координат для форм, определеных при помощи свойства `clip-path`, устанавливается, используя границы элемента, для которых `clip-path` был применен, поэтому система координат аналогична для свойств shape-*.

Благодаря этому мы можем использовать ту же фигуру, определенную в свойстве shape-* для обрезающего пути, которая вырежет или *обрежет* все то, что находится внутри объемлющего элемента и выходит за границы формы. В результате мы получим кастомную фигуру с фоном. 

Вы можете протестировать эту идею [вживую][12], только убедитесь что вы тестируете в браузере, который это поддерживает.

## Краткое (быстрое) напоминание.

На момент редактирования статьи свойство `shape-outside` работало только на плавающих элементах, а свойства `shape-outside` и `shape-inside` оба применялись только к блочным элементам или же к инлайновым элементам, *приведенным к блочным*.
Фигура, определенная как плавающая будет использовать инлайновый контент для обертки вокруг заданной формы. Будущие уровни CSS-форм позволят использовать формы не только на плавающих элементах, и когда это случится, мы сможем оборачивать контент с двух сторон формы (как на картинке ниже). Так что пока мы можем только сделать элемент плавающим, и содержимое будет обтекать его с одной из сторон.

![Расположение контента с двух сторон от CSS-формы][13]

Вы можете сэмулировать оборачивание содержимого с двух сторон, используя 
[плагин Исключающего удара (Exclusion Punch plugin)][14] от [Биара Трэвиса][15] (Bear Travis).

А теперь давайте нарисуем пару форм и создадим несколько интересных макетов!

Каждый из следующих примеров вводит новый совет, идею или технику, которые используются для определения и использования CSS-форм и исключений.

**Вы можете посмотреть живое демо для каждого примера, просто кликнув на скриншот**

### Пример 1: Плавающий текст вокруг пользовательской формы с `shape-outside` 
Мы начнем с простого примера. В этом примере мы собираемся определить пользовательскую форму и обтекающий контент. Результат будет выглядеть, как на картинке ниже:

[![Скриншот демо #1. Нажмите на скриншот, чтобы увидеть работающее демо][16]][17]

В демо-примере мы имеем два элемента: `.content` (контейнер с текстом слева) и `.shaped`, зафлоаченный вправо, который получит собственную форму и будет иметь обтекающий слева текст. Заголовок в блоке `.content` получит такое же поведение, которое мы дадим диву, зафлоаченному направо, так что я пропущу объяснения и буду рассказывать только про то, что мы делаем с блоком `.shaped`.

    <div class="container">
      <div class="shaped"></div>
      <div class="content">
        <h1><span>La</span> Tour <br/>Eiffel</h1>
        <p>Lorem Ipsum…</p>
      </div>
    </div>        

Сперва мы зададим плавающему элементу `div` конкретную высоту и ширину для установки системы координат. Мы установим высоту, равную высоте контейнера, которому для этого примера я задала равным высоте вьюпорта, используя единицу измерения `vh` из CSS.

    .container{
      overflow:hidden;
      height: 100vh;
      width: 100vw;
    }
    .shaped{
      float:left;
      height:100vh;
      width:40vw;
      float:right;
      background: black url(../images/eiffel.jpg) center top no-repeat;
      background-size:cover;
    }             

Сейчас, когда система координат готова, мы можем определить плавающие и исключающие области элемента. Тут два пути объявления формы для этого примера:

## Использование polygon()

В первом способе мы будем использовать функцию polygon(). Данная функция принимает набор точек, которые образуют прямоугольник, каждая точка задается через координаты `x` и `y`. Мы собираемся определить очень простую прямоугольную фигуру с 4 вершинами, как показано на рисунке ниже (оранжевые и голубые точки):

![][18]

Координаты точек могут иметь либо конкретные значения (`px` или `em`), либо процентные значения. В этом примере мы устанавливаем процентные значения для вершин. 
Сейчас всё, что мы должны сделать, это объявить форму на плавающем элементе так, чтобы текст обтекал его.

    .shaped{
      /*…*/
      shape-outside: polygon(0 0, 100% 0, 100% 100%, 30% 100%);
      shape-margin: 20px;
    }         

И это все! Теперь текст обтекает плавающий элемент по специальной форме, которую мы определили.

Также вы можете видеть, что я добавила внешний отступ, чем отдалила содержимое от формы и создала промежуток между ними.

Но нужно добавить кое-что еще. Как я упоминала в предыдущей части, фон плавающего элемента применяется к оригинальной прямоугольной форме, а не к форме определенной на нем, потому что свойство фона не распространяется на форму, определенную на элементе. В примере это выглядит так:

![][19]

Поэтому мы вырезаем лишнюю часть с помощью свойства `clip-path`, которому мы дадим то же значение/форму, что мы дали свойству `shape-outside` выше. Мы добавим это правило в набор правил: 

    .shaped{
      /*...*/
      clip-path: polygon(0 0, 100% 0, 100% 100%, 30% 100%);
    }
                  

Вот мы и закончили! Легко, не правда ли?

Заголовок страницы слева имеет такое же поведение, как и `div` с классом `.floated`, обтекающий справа. Заголовок плавает внутри контейнера `.content`, ему дана конкретная высота и ширина для установки системы координат, а затем на нем  устанавливается форма при помощи свойства `shape-outside` так же, как мы это делали для элемента `.floated`.

## Использование URI изображения

Второй способ, с помощью которого мы можем определять формы на элементах, – это использование изображений с альфа-каналом, то есть любых изображений с прозрачностью.

Для примера вместо использования функции `polygon()` для определения формы, мы укажем в свойстве `shape-outside` URI изображения, в результате чего браузер достанет форму из изображения и использует ее.

На примере ниже видно изображение, которое иллюстрирует исключающую область. Можно заметить, что это изображение повторяет фигуру, созданную с помощью функции `polygon()` из точек, как в предыдущем методе.

![][20]

Когда мы используем изображения с альфа-каналом для определения формы через свойство shape-outside, прозрачная область изображения будет обозначать область, где текст будет обтекать заданую форму; эта область будет называться *плавающей областью* элемента. Черная часть определяет область исключения элемента. 

Для использования этого изображения мы напишем следующее: 

    .shaped{
      /*…*/
      shape-outside: url(../images/mm.png);
      shape-image-threshold: 0.5; /* this property is used to set the threshold used
                                    for extracting a shape from an image.
                                    0.0 = fully transparent and 1.0 = fully opaque
                                  */
    }


Каждый из указанных двух методов имеет свои преимущества. Следует использовать изображения с альфа-каналом для сложных фигур, где могло бы быть затруднительно  создавать точки вручную; в этом случае создание изображения в Фотошопе будет намного проще и быстрее, чем добавление точек руками.

Другая ситуация, когда вы можете захотеть использовать URI изображения вместо функции формы, - это когда у вас много плавающих или исключающих областей в элементе; в этом случае использование этого метода обязательно, потому что вы не можете (пока что) объявлять несколько форм на одном элементе, но если изображение имеет много областей, браузер извлечет эти области из изображения и будет использовать их. 
Неплохо, правда? Пример такого случая в последнем демо. 


### Пример 2: обворачивание/обтекание текста внутри пользовательской формы при помощи shape-inside

Для второго примера мы создадим простую демонстрацию, где окончательный результат будет выглядеть вот так:

[![][21]][22]

Цель этого примера - показать использование свойства `shape-inside` для плавающего текста в непрямоугольной форме. У нас есть контейнер с несколькими заглушками текста внутри него и фоновая фотография у контейнера.

    <div class="container">            
      <div class="content">
          <p>…</p>
      </div>
      <h2>Corn Bread</h2>
    </div>    

На этом скриншоте мы видим, что текст находится внутри округлой формы вверху. А это означает, что нам нужно будет объявить круг на нашем контейнере. Так же, как и в предыдущем примере, у нас есть два способа, которыми это можно сделать:

### Использование `circle()` 

Функция `circle()` имеет три аргумента: `cx`, `cy` и `r` (радиус), где `cx` и `cy` - координаты центра окружности, а `r` — это радиус окружности.

На рисунке ниже видно, что система координат установлена на элементе, и окружность находится внутри элемента. Мы можем убедиться, что окружность установлена над изображением сковороды на фотографии, которую мы используем как фоновое изображение, так что кажется, что текст содержится внутри сковородки. 
На картинке так же видна позиция центра окружности относительно системы координат, установленной на элементе.

![][23]

Так как мы хотим обернуть текст *внутри* пользовательской формы и не обтекать его вокруг, мы собираемся использовать свойство `shape-inside` на элементе, который содержит этот текст. Когда мы применяем свойство `shape-inside` к элементу, мы должны помнить, что этот элемент должен иметь текст внутри себя, что не похоже на  предыдущий пример, где контент был снаружи. 

На этот раз мы укажем координаты центра окружности в абсолютных величинах, а не в процентах, установим значение радиуса и применим это все к контейнеру: 

    .container{
      float:left;
      width:600px;
      height:900px;
      overflow:hidden;
      margin:0 50px;
      color:white;
      font-size:13px;
      padding:10px;
      background: url(../images/pan.jpg) top left no-repeat;
      background-size:100% 100%;
      /* declare shape using the shape function circle() */
      shape-inside: circle(400px, 60px, 160px);
    }

Конечно, если вы не пытаетесь создать окружность идеальной формы, вы также можете определить форму при помощи функиции `polygon()`.


### Использование URI изображения

Мы также можем использовать URI изображения с альфа-каналом, чтобы достать форму окружности из нее. Картинка будет выглядеть следующим образом:

![][24]

Здесь очень важно отметить, что, когда мы используем изображения с альфа-каналом для определения формы **со свойством `shape-inside`**, *черная (или непрозрачная) область* изображения будет определять область, где будет находится текст. В прошлом примере непрозрачная область определяла *область исключения* элемента, на котором мы применяли форму, т.е. область, где нет текста. 

Чтобы определить форму, используя URI изображения вместо функции `circle()`, вы должны будете указать в значении свойства `shape-inside` URI изображения.   

    .container{
      /*...*/
      shape-inside: url(mask.png) top left;
    }             


### Пример 3: обворачивание/обтекание текста внутри пользовательской формы при помощи shape-inside

В этом примере мы также объявим многоугольную форму на контейнере и зададим контент внутри этой формы. Конечный результат будет выглядеть вот так:

![][25]

В данном случае мы также можем использовать функцию для описания формы или изображения с альфа-каналом.

Форма, объявленная для этого контейнера, — это явно «произвольная» многоугольная форма, а не геометрическая форма, которую можно было бы объявить, используя функции форм вроде `circle()`, `ellipse()` или `rectangle()`, поэтому для ее объявления мы будем использовать функцию `polygon()`. 

На рисунке снизу показана форма, задаваемая набором точек.

![][26]

Так как эта форма задается довольно большим количество точек, вычислять их координаты было бы утомительно, поэтому было бы намного проще, если бы существовал *визуальный* инструмент, который помог бы расставить точки на изображении, правда ведь? И такой инструмент существует и создан [Биаром Трэвисом][27] из Adobe; на самом деле, это набор инструментов, который поможет вам при работе с CSS-формами. Обязательно посмотрите на [Shape Tools][28], потому что они очень полезны.

Один из инструментов Shape tools называется [Poly Draw][29], и он позволяет вам вручную рисовать формы, в частности многоугольники, а затем генерирует координаты формы, которые вы можете скопировать и вставить в свой CSS, чтобы задать форму на элементе.  

Я использовала инструмент Poly Draw для того чтобы нарисовать форму, изображенную на рисунке сверху. Вы не можете указать инструменту изображение, на котором вы бы нарисовали свою форму, в качестве фонового, поэтому я склонировала репозиторий, немного изменила код, применила свое изображение и расставила точки. 

[Рэзвэн Кэлимэн][30] (Razvan Caliman) предложил мне эту идею, когда я спросила его о доступности инструмента, который позволял бы определять формы на картинке прямо в браузере, такого же как, и тот, что он показывал во время [своего выступления на CSS-конференции Conf EU][31]. Если вы еще не видели, то обязательно посмотрите. Исходники этого инструмента когда-нибудь (очень надеюсь, что скоро), будут открыты компанией Adobe, и тогда этот инструмент станет незаменимым при работе с CSS-формами. Ну, а пока можно обходиться инструментом Poly Draw.

После того как вы нарисовали форму при помощи Poly Draw, вам нужно только объявить результирующую форму элемента. 

    .container{
      width:445px;
      height:670px;
      overflow:hidden;
      margin:30px auto;
      /*shape generated by the Poly Draw tool*/
      shape-outside: polygon(170.67px 291.00px,126.23px 347.56px,139.79px 417.11px,208.92px 466.22px,302.50px 482.97px,343.67px 474.47px,446.33px 452.00px,443.63px 246.82px,389.92px 245.63px,336.50px 235.26px,299.67px 196.53px,259.33px 209.53px,217.00px 254.76px);
    }    

Мы также можем определить вышеупомянутую форму, используя изображение с альфа-каналом. Картинка ниже показывает, как это изображение будет выглядеть. И снова черные области определяют плавающую область, в которой текст будет находиться, когда мы используем свойство `shape-inside`.

![][32]

Если вы хотите использовать URI изображения вместо функции формы, вы должны заменить значение формы следующим кодом: 

    .container{
      /*...*/
      shape-inside: url(mask.png) top left;
    }           


### Пример 4: Множественные области с `shape-inside` 

В этом примере мы собираемся создать множественные области внутри элементов, в которых заключим контент. Результирующее демо показано на нижеследующем рисунке: 

![][33]

Мы имеем `div` с фоновым изображением, и мы хотим, чтобы текст внутри этого `div` тек внутри определенных областей, каждая из которых имеет пользовательскую форму.

    <div class="container">
      <div class="content">
          <h2>Rosemary Sandwich</h2>
          <p>…</p>
      </div>
    </div>      

Так как мы не можем объявить несколько форм на элементе, мы будем использовать изображение с альфа-каналом. Изображение может содержать любое количество форм и областей, поэтому оно идеально определяет множество форм элемента; браузер извлекает все формы из изображения и использует их на элементе. Мы будем использовать следующее изображение для определения форм. Черные области на изображении будут определять области для контента внутри элемента `.container`, где будет содержаться текст.

![][34]

В определении элемента `.container` в значение свойста `shape-inside` мы подставим наше изображение с альфа-каналом и не забудем указать блоку высоту и ширину:

    .container{
      width:556px;
      height:835px;
      overflow:hidden;
      margin:0 50px;
      color:white;
      position:relative;
      background: url(../images/bread.jpg) top left no-repeat;
      background-size: 100% 100%;
      shape-inside: url(mask.png) top left;
      font-size:13px;
    }          

Вот мы и закончили. Оставшуюся работу за нас сделал браузер, достав формы из изображения, которое мы ему дали, и аккуратно расположив текст внутри этих форм.

Использовать изображения для определения форм вполне логично, когда вы имеете раздельные области, не соединенные друг с другом, то есть когда нельзя сформировать многоугольник. Для следующего демо мы могли бы использовать функцию `polygon()` для определения формы; определение многоугольника выглядело бы следующим образом:

![][35]

Но как вы уже успели заметить, это не лучшая идея. Я просто добавила этот пример, чтобы показать разницу между использованием изображений и определением форм через `polygon()` и продемонстрировать, что иногда более осмысленно и уместно использовать изображение, даже если вы можете построить функцию для определения формы.  


## Комбинирование CSS-форм с регионами и флексбоксами для создания журнальных макетов 

Обычное бумажные журналы используют комбинацию многоколоночного текста с непрямоугольными формами для создания необычного и привлекательного дизайна. Колонки обычно одинаковой высоты, если не требуется обратного.

После того как планируемые возможности CSS-форм будут реализованы, и обворачивание контента с двух сторон формы станет возможным, создание макетов наподобие печатных журналов станет реальным, и тогда мы сможем комбинировать формы и исключения с регионами и флексбоксами.

[![][36]][37]

Флексбоксы дают нам столбцы одинковой высоты; регионы позволяют размещать текст в разных областях страницы и разделять содержимое страницы от его расположения; формы и исключения позволят нам добавить тот финальный штрих, который выведет "журнальную" верстку на новый уровень. 


## Финальные слова

Еще ни одна возможность CSS не вызывала во мне столько восторга, как CSS-формы и исключения. Мощность, гибкость и разнообразние, которые предоставляют новые возможности в сочетании с регионами и флекбоксами, просто потрясают.

В скором времени должна появиться широкая поддержка CSS-форм; команда веб-разработчиков из Adobe постоянно работает над улучшением и внедрением новых возможностей, а также предоставляет инструменты для упрощения работы с ними. 

Будущее веб-разработки выглядит все ярче и привлекательней с каждым днем. Хорошо быть веб-разработчиком!

Я надеюсь, что эта статья поможет вам войти в технический курс дела относительно CSS-форм и исключений. Это не последняя моя статья на эту тему. Комбинирование CSS-форм с другими передовыми технологиями мира CSS, такими как регионы, открывает двери в новый мир творческих идей и создания новых статей! ;)  

[1]: http://css-tricks.com/examples/ShapesOfCSS/
[2]: http://blogs.adobe.com/webplatform/2013/10/23/css-shapes-visual-storytelling/
[3]: https://src.chromium.org/viewvc/blink?revision=159989&view=revision
[4]: http://html.adobe.com/webplatform/enable/
[5]: http://www.w3.org/TR/2007/WD-css3-box-20070809/
[6]: http://blogs.adobe.com/webplatform/2014/02/11/new-css-shapes-syntax/
[7]: http://www.w3.org/TR/css-shapes/#CSS3BOX
[8]: http://www.w3.org/TR/css-shapes/
[9]: img/shape-background.png
[10]: img/box-model-background.png
[11]: https://dvcs.w3.org/hg/FXTF/raw-file/default/masking/index.html
[12]: http://codepen.io/SaraSoueidan/pen/ad12e1280e4b1c481faa3b82bd9a3263
[13]: img/shapes_CSS2.1_MBP.png
[14]: http://betravis.github.io/shape-tools/exclusion-punch/
[15]: https://twitter.com/bear_travis
[16]: img/demo-screenshot1.png
[17]: http://sarasoueidan.com/blog/css-shapes/demo-1/index.html]
[18]: img/demo-shape.png
[19]: img/demo-screenshot-incomplete.png
[20]: img/mask.png
[21]: img/demo-screenshot2.png
[22]: http://sarasoueidan.com/demos/css-shapes-layouts/demo-2/index.html
[23]: img/demo-shape1.png
[24]: img/mask1.png
[25]: img/demo-screenshot3.png
[26]: img/demo-shape2.png
[27]: https://twitter.com/bear_travis
[28]: http://betravis.github.io/shape-tools/
[29]: http://betravis.github.io/shape-tools/polygon-drawing/
[30]: https://twitter.com/razvancaliman
[31]: https://www.youtube.com/watch?v=zsLwZhTSuQk&list=PL8rji95IPUUDu3puqqxWMKFXf-NQ4z7WE&index=11
[32]: img/mask2.png
[33]: img/demo-screenshot4.png
[34]: img/mask3.png
[35]: img/demo-shape3.png
[36]: img/multicolumn-shapes.png
[37]: http://www.behance.net/gallery/Travel-Magazine/2159303

















